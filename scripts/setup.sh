#!/usr/bin/env bash
set -euo pipefail

# HeySummon Self-Hosting Setup Wizard
# ------------------------------------
# Configures Guard-aware networking with Docker Compose profiles.
# All tunnel services connect to Guard (single entry point), NOT directly to Platform.

BLUE='\033[0;34m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
NC='\033[0m'
BOLD='\033[1m'
DIM='\033[2m'

DIR="$(cd "$(dirname "$0")/.." && pwd)"

info()  { echo -e "${BLUE}ℹ${NC}  $*"; }
ok()    { echo -e "${GREEN}✓${NC}  $*"; }
warn()  { echo -e "${YELLOW}⚠${NC}  $*"; }
err()   { echo -e "${RED}✗${NC}  $*"; }

header() {
  echo ""
  echo -e "${BOLD}╔══════════════════════════════════════════╗${NC}"
  echo -e "${BOLD}║   HeySummon Self-Hosting Setup Wizard    ║${NC}"
  echo -e "${BOLD}╚══════════════════════════════════════════╝${NC}"
  echo ""
  echo -e "${DIM}Architecture: Consumer → Tunnel → Guard → Platform${NC}"
  echo ""
}

# ── Helpers ──────────────────────────────────────────

prompt() {
  local var="$1" msg="$2" default="${3:-}"
  if [[ -n "$default" ]]; then
    read -rp "$(echo -e "${BLUE}?${NC}  ${msg} [${default}]: ")" val
    eval "$var=\"${val:-$default}\""
  else
    read -rp "$(echo -e "${BLUE}?${NC}  ${msg}: ")" val
    eval "$var=\"$val\""
  fi
}

prompt_secret() {
  local var="$1" msg="$2"
  read -srp "$(echo -e "${BLUE}?${NC}  ${msg}: ")" val
  echo ""
  eval "$var=\"$val\""
}

choose_connectivity() {
  echo ""
  echo -e "${BOLD}Choose a connectivity option:${NC}"
  echo ""
  echo "  1) Cloudflare Tunnel  (recommended — free, custom domain, SSE-friendly)"
  echo "  2) Tailscale Funnel   (easy, uses your Tailscale network)"
  echo "  3) Ngrok              (quick start, random URL on free tier)"
  echo "  4) None / Manual      (you handle port forwarding yourself)"
  echo ""
  echo -e "${DIM}  All tunnel options route traffic through Guard for content safety.${NC}"
  echo ""
  read -rp "$(echo -e "${BLUE}?${NC}  Enter choice [1-4]: ")" choice
}

# ── Ed25519 Key Generation ──────────────────────────

generate_guard_keys() {
  echo ""
  info "Checking Ed25519 Guard keys..."

  if [[ -f "$DIR/.guard-public-key" && -f "$DIR/.guard-signing-key" ]]; then
    ok "Guard keys already exist (use Docker volume keys in production)"
    return
  fi

  # Keys are auto-generated by docker compose via guard-keygen service.
  # For local dev or manual setups, generate them here.
  if command -v node &>/dev/null; then
    node -e "
      const nacl = require('tweetnacl') || (() => { console.log('tweetnacl not available — keys will be generated by Docker on first start.'); process.exit(0); })();
      const kp = nacl.sign.keyPair();
      const priv = Buffer.from(kp.secretKey).toString('hex');
      const pub = Buffer.from(kp.publicKey).toString('hex');
      require('fs').writeFileSync('$DIR/.guard-signing-key', priv);
      require('fs').writeFileSync('$DIR/.guard-public-key', pub);
    " 2>/dev/null && ok "Generated Ed25519 Guard keys locally" || {
      info "Guard keys will be auto-generated by Docker on first start"
    }
  else
    info "Node.js not found locally — Guard keys will be auto-generated by Docker on first start"
  fi
}

# ── Generate .env ────────────────────────────────────

generate_env() {
  local env_file="$DIR/.env"

  # Preserve existing values
  local existing_db_url="" existing_secret="" existing_mercure_secret=""
  local existing_github_id="" existing_github_secret=""
  if [[ -f "$env_file" ]]; then
    existing_db_url=$(grep '^DATABASE_URL=' "$env_file" 2>/dev/null | cut -d= -f2- || true)
    existing_secret=$(grep '^NEXTAUTH_SECRET=' "$env_file" 2>/dev/null | cut -d= -f2- || true)
    existing_mercure_secret=$(grep '^MERCURE_JWT_SECRET=' "$env_file" 2>/dev/null | cut -d= -f2- || true)
    existing_github_id=$(grep '^AUTH_GITHUB_ID=' "$env_file" 2>/dev/null | cut -d= -f2- || true)
    existing_github_secret=$(grep '^AUTH_GITHUB_SECRET=' "$env_file" 2>/dev/null | cut -d= -f2- || true)
  fi

  local secret="${existing_secret:-$(openssl rand -hex 32)}"
  local mercure_secret="${existing_mercure_secret:-$(openssl rand -hex 32)}"

  prompt NEXTAUTH_URL "Public URL for your HeySummon instance" "${PUBLIC_URL:-http://localhost:3425}"

  cat > "$env_file" <<EOF
# HeySummon Environment Configuration
# Generated by setup wizard on $(date -Iseconds)

# ─── Required Secrets ─────────────────────────────────
NEXTAUTH_SECRET=${secret}
MERCURE_JWT_SECRET=${mercure_secret}

# ─── Database ─────────────────────────────────────────
DATABASE_URL=${existing_db_url:-postgresql://heysummon:heysummon_dev@db:5432/heysummon}

# ─── URLs ─────────────────────────────────────────────
NEXTAUTH_URL=${NEXTAUTH_URL}
HEYSUMMON_PUBLIC_URL=${NEXTAUTH_URL}

# ─── Auth ─────────────────────────────────────────────
AUTH_GITHUB_ID=${existing_github_id}
AUTH_GITHUB_SECRET=${existing_github_secret}

# ─── Connectivity ─────────────────────────────────────
CONNECTIVITY_METHOD=${CONNECTIVITY_METHOD}
EOF

  # Append connectivity-specific vars
  case "$CONNECTIVITY_METHOD" in
    cloudflare)
      cat >> "$env_file" <<EOF
CLOUDFLARE_TUNNEL_TOKEN=${CF_TOKEN}
EOF
      ;;
    tailscale)
      cat >> "$env_file" <<EOF
TAILSCALE_AUTHKEY=${TS_KEY}
EOF
      ;;
    ngrok)
      cat >> "$env_file" <<EOF
NGROK_AUTHTOKEN=${NGROK_TOKEN}
EOF
      [[ -n "${NGROK_DOMAIN:-}" ]] && echo "NGROK_DOMAIN=${NGROK_DOMAIN}" >> "$env_file"
      ;;
  esac

  ok "Generated .env"
}

# ── Generate docker-compose.override.yml ─────────────
# With profiles in docker-compose.yml, the override is minimal.
# It only adds env_file references for convenience.

generate_override() {
  local override="$DIR/docker-compose.override.yml"

  cat > "$override" <<'EOF'
# Auto-generated by setup wizard
# Tunnel services are built into docker-compose.yml as profiles.
# Start with: docker compose --profile <method> up -d
#
# This override adds env_file to core services.
services:
  app:
    env_file: .env
  heysummon-guard:
    env_file: .env
EOF

  ok "Generated docker-compose.override.yml"
}

# ── Connectivity setup ───────────────────────────────

setup_cloudflare() {
  CONNECTIVITY_METHOD="cloudflare"
  echo ""
  info "Cloudflare Tunnel Setup"
  echo ""
  info "1. Go to https://one.dash.cloudflare.com → Networks → Tunnels"
  info "2. Create a tunnel, name it 'heysummon'"
  warn "3. Set the tunnel's public hostname to point to ${BOLD}http://heysummon-guard:3000${NC}"
  info "   (Guard is the entry point — NOT the Platform directly)"
  echo ""
  prompt_secret CF_TOKEN "Cloudflare Tunnel token"
  if [[ -z "$CF_TOKEN" ]]; then
    err "Token is required"; exit 1
  fi
  PUBLIC_URL=""
  prompt PUBLIC_URL "Your custom domain (e.g. https://heysummon.example.com)"
}

setup_tailscale() {
  CONNECTIVITY_METHOD="tailscale"
  echo ""
  info "Tailscale Funnel Setup"
  echo ""
  info "1. Generate an auth key at https://login.tailscale.com/admin/settings/keys"
  info "2. Enable Funnel in your Tailscale ACL policy"
  info "Traffic will route through Guard automatically via the serve config."
  echo ""
  prompt_secret TS_KEY "Tailscale auth key"
  if [[ -z "$TS_KEY" ]]; then
    err "Auth key is required"; exit 1
  fi
  PUBLIC_URL="https://heysummon.<your-tailnet>.ts.net"
  warn "Your URL will be https://heysummon.<tailnet-name>.ts.net"
}

setup_ngrok() {
  CONNECTIVITY_METHOD="ngrok"
  echo ""
  info "Ngrok Setup"
  echo ""
  info "Get your auth token at https://dashboard.ngrok.com/get-started/your-authtoken"
  info "Ngrok will tunnel to Guard (heysummon-guard:3000) automatically."
  echo ""
  prompt_secret NGROK_TOKEN "Ngrok auth token"
  if [[ -z "$NGROK_TOKEN" ]]; then
    err "Auth token is required"; exit 1
  fi
  prompt NGROK_DOMAIN "Custom domain (leave empty for random URL)" ""
  if [[ -n "$NGROK_DOMAIN" ]]; then
    PUBLIC_URL="https://${NGROK_DOMAIN}"
  else
    PUBLIC_URL="(will be shown after starting ngrok — check http://localhost:4040)"
    warn "Free ngrok URLs change on restart. Check http://localhost:4040/status for current URL."
  fi
}

setup_direct() {
  CONNECTIVITY_METHOD="direct"
  PUBLIC_URL="http://localhost:3425"
  warn "No tunnel configured. Guard is still the entry point on port 3000."
  info "You can add a reverse proxy (Nginx/Caddy) in front of Guard."
}

# ── Connectivity test ────────────────────────────────

test_connectivity() {
  echo ""
  info "Running connectivity tests..."
  echo ""

  local guard_url="http://localhost:${GUARD_PORT:-3000}"
  local all_ok=true

  # Test 1: Guard health
  if command -v curl &>/dev/null; then
    if curl -sf "${guard_url}/health" >/dev/null 2>&1; then
      ok "Guard is reachable at ${guard_url}/health"
    else
      warn "Guard not reachable at ${guard_url}/health (may still be starting)"
      all_ok=false
    fi
  fi

  # Test 2: Platform health (through Guard)
  if command -v curl &>/dev/null; then
    local health
    health=$(curl -sf "${guard_url}/api/health" 2>/dev/null || echo "")
    if [[ -n "$health" ]]; then
      ok "Platform health endpoint responding through Guard"
      echo -e "  ${DIM}${health}${NC}"
    else
      warn "Platform not reachable through Guard (may still be starting)"
      all_ok=false
    fi
  fi

  # Test 3: SSE endpoint
  if command -v curl &>/dev/null; then
    local sse_status
    sse_status=$(curl -sf -o /dev/null -w '%{http_code}' "${guard_url}/api/v1/events/stream" 2>/dev/null || echo "000")
    if [[ "$sse_status" == "401" || "$sse_status" == "200" ]]; then
      ok "SSE endpoint reachable through Guard (HTTP ${sse_status})"
    else
      warn "SSE endpoint returned HTTP ${sse_status}"
      all_ok=false
    fi
  fi

  echo ""
  if [[ "$all_ok" == "true" ]]; then
    ok "All connectivity tests passed!"
  else
    warn "Some tests did not pass — the stack may still be starting up."
    info "Wait 30 seconds and run: curl http://localhost:${GUARD_PORT:-3000}/api/health"
  fi
}

# ── Main ─────────────────────────────────────────────

header

# Check prerequisites
for cmd in docker openssl; do
  if ! command -v "$cmd" &>/dev/null; then
    err "$cmd is required but not installed"
    exit 1
  fi
done

if docker compose version &>/dev/null; then
  ok "Docker Compose available"
else
  err "Docker Compose is required (docker compose plugin)"
  exit 1
fi

# Step 1: Choose connectivity
choose_connectivity

case "$choice" in
  1) setup_cloudflare ;;
  2) setup_tailscale ;;
  3) setup_ngrok ;;
  4) setup_direct ;;
  *) err "Invalid choice"; exit 1 ;;
esac

# Step 2: Generate Guard keys
generate_guard_keys

# Step 3: Generate config files
generate_env
generate_override

# Step 4: Summary
echo ""
echo -e "${BOLD}── Summary ──────────────────────────────────${NC}"
echo -e "  Connectivity:  ${GREEN}${CONNECTIVITY_METHOD}${NC}"
echo -e "  Public URL:    ${GREEN}${PUBLIC_URL}${NC}"
echo -e "  Entry point:   ${GREEN}Guard (:${GUARD_PORT:-3000})${NC} → Platform (internal)"
echo -e "  Config files:  .env, docker-compose.override.yml"
echo ""

if [[ "$CONNECTIVITY_METHOD" != "direct" ]]; then
  echo -e "${DIM}  Start with: docker compose --profile ${CONNECTIVITY_METHOD} up -d${NC}"
else
  echo -e "${DIM}  Start with: docker compose up -d${NC}"
fi
echo ""

# Step 5: Start the stack
read -rp "$(echo -e "${BLUE}?${NC}  Start the stack now? [Y/n]: ")" start_now
if [[ "${start_now,,}" != "n" ]]; then
  info "Starting HeySummon..."
  cd "$DIR"
  if [[ "$CONNECTIVITY_METHOD" != "direct" ]]; then
    docker compose --profile "$CONNECTIVITY_METHOD" up -d
  else
    docker compose up -d
  fi
  echo ""
  ok "Stack is starting! Check logs with: docker compose logs -f"

  # Step 6: Connectivity test
  echo ""
  read -rp "$(echo -e "${BLUE}?${NC}  Want to run a quick connectivity test? [Y/n]: ")" run_test
  if [[ "${run_test,,}" != "n" ]]; then
    info "Waiting 10 seconds for services to start..."
    sleep 10
    test_connectivity
  fi
else
  info "Start manually with the command shown above."
fi

echo ""
echo -e "${GREEN}${BOLD}Setup complete!${NC}"
echo -e "API endpoint: ${BOLD}${PUBLIC_URL}${NC}"
echo ""
